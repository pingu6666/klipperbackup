







[gcode_macro bed_mesh_calibrate_fast]
description: Wraps BED_MESH_CALIBRATE, scaling probe count to specified area.
  Usage: See Klipper documentation.
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set probe_mesh_padding = km.probe_mesh_padding %}
  {% set probe_min_count = km.probe_min_count %}
  {% set probe_count_scale = km.probe_count_scale %}
  {% set bed_mesh = printer.configfile.config.bed_mesh %}

  # Don't have the math functions available to work on a delta bed, and
  # not sure how to make relative reference index work.
  {%if "mesh_radius" not in bed_mesh and
       "MESH_RADIUS" not in params and
       "relative_reference_index" not in bed_mesh and
       "RELATIVE_REFERENCE_INDEX" not in params %}
    {% set safe_min_x = bed_mesh.mesh_min.split(",")[0]|float %}
    {% set safe_min_y = bed_mesh.mesh_min.split(",")[1]|float %}
    {% set safe_max_x = bed_mesh.mesh_max.split(",")[0]|float %}
    {% set safe_max_y = bed_mesh.mesh_max.split(",")[1]|float %}

    # Always bound MESH_MIN and MESH_MAX.
    {% if "MESH_MIN" in params %}
      {% set mesh_min_x = (params.MESH_MIN.split(",")[0]|float -
                           probe_mesh_padding, safe_min_x)|max %}
      {% set mesh_min_y = (params.MESH_MIN.split(",")[1]|float -
                           probe_mesh_padding, safe_min_y)|max %}
    {% else %}
      {% set mesh_min_x = safe_min_x %}
      {% set mesh_min_y = safe_min_y %}
    {% endif %}
    {% if "MESH_MAX" in params %}
      {% set mesh_max_x = (params.MESH_MAX.split(",")[0]|float +
                           probe_mesh_padding, safe_max_x)|min %}
      {% set mesh_max_y = (params.MESH_MAX.split(",")[1]|float +
                           probe_mesh_padding, safe_max_y)|min %}
    {% else %}
      {% set mesh_max_x = safe_max_x %}
      {% set mesh_max_y = safe_max_y %}
    {% endif %}

    {% set probe_count = (params.PROBE_COUNT |
                          default(bed_mesh.probe_count)).split(",") %}
    # Don't scale the probe count if one was explicitly provided.
    {% if "PROBE_COUNT" not in params %}
        {% set max_x_probes = probe_count[0]|int %}
        {% set max_y_probes = probe_count[1]|default(max_x_probes)|int %}

        {% set x_probes = (max_x_probes * (mesh_max_x - mesh_min_x) /
                        (safe_max_x - safe_min_x) * probe_count_scale)
                        | round(0) | int %}
        {% set x_probes = ((x_probes, probe_min_count)|max, max_x_probes)|min %}

        {% set y_probes = (max_y_probes * (mesh_max_y - mesh_min_y ) /
                        (safe_max_y - safe_min_y) * probe_count_scale )
                        | round(0) | int %}
        {% set y_probes = ((y_probes, probe_min_count)|max, max_y_probes)|min %}
        {% set probe_count = [x_probes,y_probes] %}
    {% endif %}
    {% set dummy = params.__setitem__("MESH_MIN", mesh_min_x~","~mesh_min_y) %}
    {% set dummy = params.__setitem__("MESH_MAX", mesh_max_x~","~mesh_max_y) %}
    {% set dummy = params.__setitem__("PROBE_COUNT", probe_count|join(',')) %}
  {% endif %}
  {% if printer["gcode_macro bed_mesh_calibrate"].km_override|default(False) %}
    {% set calibrate_cmd = "_km_bed_mesh_calibrate_base" %}
  {% else %}
    {% set calibrate_cmd = "BED_MESH_CALIBRATE" %}
  {% endif %}
  BED_MESH_CHECK
  {calibrate_cmd}{%for k in params%}{' '~k~'="'~params[k]~'"'}{%endfor%}

[gcode_macro bed_mesh_check]
description: Warns if bed_mesh config may generate an invalid mesh.
  Usage: See Klipper documentation.
gcode:
  {% if printer.bed_mesh is defined %}
    {% set x_min = printer.configfile.settings.stepper_x.position_min %}
    {% set y_min = printer.configfile.settings.stepper_y.position_min %}
    {% set x_max = printer.configfile.settings.stepper_x.position_max %}
    {% set y_max = printer.configfile.settings.stepper_y.position_max %}

    {% set mesh_min_x = printer.configfile.settings.bed_mesh.mesh_min[0] %}
    {% set mesh_min_y = printer.configfile.settings.bed_mesh.mesh_min[1] %}
    {% set mesh_max_x = printer.configfile.settings.bed_mesh.mesh_max[0] %}
    {% set mesh_max_y = printer.configfile.settings.bed_mesh.mesh_max[1] %}

    {% if "bltouch" in printer.configfile.settings %}
        {% set x_offset = printer.configfile.settings.bltouch.x_offset %}
        {% set y_offset = printer.configfile.settings.bltouch.y_offset %}
        {% set probe = "bltouch" %}
    {% elif "probe" in printer.configfile.settings %}
        {% set x_offset = printer.configfile.settings.probe.x_offset %}
        {% set y_offset = printer.configfile.settings.probe.y_offset %}
        {% set probe = "probe" %}
    {% else %}
        {% set x_offset = 0.0 %}
        {% set y_offset = 0.0 %}
    {% endif %}

    {% set output = [] %}
    {% set warn =
         "* bed_mesh.mesh_%s (%f, %f) does not account for " ~ probe ~
         ".%s_offset (%f) and can move out of range for "
         "stepper_%s.position_%s (%f)." %}
    {% if x_offset > 0 and (mesh_min_x - x_offset) < x_min %}
      {% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
                                           'x', x_offset, 'x', 'min', x_min)) %}
    {% elif x_offset < 0 and (mesh_max_x - x_offset) > x_max %}
      {% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
                                           'x', x_offset, 'x', 'max', x_max)) %}
    {% endif %}
    {% if y_offset > 0 and (mesh_min_y - y_offset) < y_min %}
      {% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
                                           'y', y_offset, 'y', 'min', y_min)) %}
    {% elif y_offset < 0 and (mesh_max_y - y_offset) > y_max %}
      {% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
                                           'y', y_offset, 'y', 'max', y_max)) %}
    {% endif %}

    {% if output %}
      { action_respond_info(
        "Warning: The following issue(s) were detected in your [bed_mesh] "
        " config:\n" ~ output|join("\n")) }
    {% endif %}
  {% endif %}



  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
#
# Credit to original source:
# https://klipper.discourse.group/t/saving-and-adjusting-per-build-surface-z-offsets/696 

[gcode_macro _apply_bed_surface_offset]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if surfaces.active %}
    SET_SURFACE_ACTIVE SURFACE={surfaces.active}
  {% endif %}

[gcode_macro _init_surfaces]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if "bed_surfaces" in printer.save_variables.variables %}
    {% set old_surfaces = printer.save_variables.variables.bed_surfaces %}
  {% else %}
    {% set old_surfaces = { 'active' : '', 'available' : {} } %}
  {% endif %}
  {% set settings = printer.configfile.settings %}
  {% set new_probe_z = (settings.probe | default(settings.bltouch) |
                        default(settings.smart_effector) | default({})
                        ).z_offset|default(0.0)|float %}
  {% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
                        default(0.0)|float %}
  {% if 'endstop_z' not in old_surfaces %}
    {% set dummy = old_surfaces.__setitem__('endstop_z', new_endstop_z) %}
  {% endif %}
  {% if 'probe_z' not in old_surfaces %}
    {% set dummy = old_surfaces.__setitem__('probe_z', new_probe_z) %}
  {% endif %}
  {% set surfaces = { 'active' : '', 'available' : {},
                      'endstop_z' : old_surfaces.endstop_z,
                      'probe_z' : old_surfaces.probe_z } %}
  {% for s in km.bed_surfaces %}
    {% set s = s.split()|join(' ')|lower %}
    {% if s|length > km.bed_surface_max_name_length or
          s|list|select("in", " \r\n\"\'")|list %}
      {action_raise_error('Invalid surface name "%s". Name must be 10 or fewer '
        'characters and must not include space or quotation characters'
        | format(s))}
    {% endif %}
    {% if s in old_surfaces.available %}
      {% set dummy = surfaces.available.__setitem__(s,
                       old_surfaces.available[s]) %}
    {% else %}
      {% set dummy = surfaces.available.__setitem__(s, {'offset' : 0.0}) %}
    {% endif %}
  {% endfor %}
  {% if old_surfaces.active in surfaces.available %}
    {% set dummy = surfaces.__setitem__('active', old_surfaces.active) %}
  {% elif km.bed_surfaces %}
    {% set dummy = surfaces.__setitem__('active', km.bed_surfaces[0]|lower) %}
  {% endif %}
  SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
  _APPLY_BED_SURFACE_OFFSET
  {% if new_probe_z != surfaces.probe_z or
        new_endstop_z != surfaces.endstop_z %}
    { action_respond_info(
      'Z probe offset or endstop position changed. Run ADJUST_SURFACE_OFFSETS '
      'to adjust the offset for all saved surfaces by the change differential, '
      'or run ADJUST_SURFACE_OFFSETS IGNORE to hide this message without '
      'making changes.') }
  {% endif %}
[gcode_macro adjust_surface_offsets]
description: Adjusts surface offsets to account for changes in the Z endstop
  position or probe Z offset.
  Usage: ADJUST_SURFACE_OFFSETS [IGNORE]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set settings = printer.configfile.settings %}
  {% set new_probe_z = (settings.probe | default(settings.bltouch) |
                        default(settings.smart_effector) | default({})
                        ).z_offset|default(0.0)|float %}
  {% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
                          default(0.0)|float %}
  {% set diff = (surfaces.probe_z - new_probe_z +
                 surfaces.endstop_z - new_endstop_z)|round(6) %}
  {% if not params.IGNORE|default(0)|int %}
    {% for s in surfaces.available %}
      {% set offset = (surfaces.available[s].offset - diff)|round(6) %}
      {% set dummy = surfaces.available.__setitem__(s, {'offset' : offset}) %}
    {% endfor %}
    { action_respond_info("All bed surfaces now adjusted by %1.4f"|
                          format(diff))}
  {% elif diff != 0 %}
    { action_respond_info("Status cleared without adjustment") }
  {% endif %}
  {% set dummy = surfaces.__setitem__('endstop_z', new_endstop_z| round(6)) %}
  {% set dummy = surfaces.__setitem__('probe_z', new_probe_z|round(6)) %}
  SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
[gcode_macro set_surface_offset]
description: Sets the offset for a surface and moves the toolhead (if homed).
  Usage: SET_SURFACE_OFFSET [OFFSET=<offset>] [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
  {% if SURFACE not in surfaces.available %}
    { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
  {% endif %}
  {% set active = surfaces.available[SURFACE] %}
  # If no offset is provided just print out the current offset.
  {% set OFFSET = params.OFFSET|default(active.offset)|float %}
  {% if OFFSET != active.offset %}
    {% set dummy = surfaces.available[SURFACE].__setitem__("offset", OFFSET) %}
    SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% if SURFACE == surfaces.active %}
      _km_set_gcode_offset_base Z="{OFFSET}" MOVE={
        1 if printer.toolhead.homed_axes == 'xyz' else 0}
    {% endif %}
  {% endif %}
  { action_respond_info("Bed surface: %s Offset: %.3f"
                        | format(SURFACE, OFFSET)) }
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SURFACE|default(active surface) %}
  {% set dummy = params.OFFSET|default(none)|float %}
  " %} # End argument block for Mainsail
[gcode_macro set_surface_active]
description: Sets the active bed surface and moves the toolhead (if homed). If
  no SURFACE argument is present the available surfaces are listed and the
  active one is preceded by a "*".
  Usage: SET_SURFACE_ACTIVE [SURFACE=<surface>]
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if "SURFACE" in params %}
    {% set SURFACE = params.SURFACE|lower %}
    {% if SURFACE not in surfaces.available %}
      { action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
    {% endif %}
    {% if SURFACE != surfaces.active %}
      {% set dummy = surfaces.__setitem__("active", SURFACE) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% endif %}
    {% if surfaces.available[SURFACE].offset !=
          printer.gcode_move.homing_origin.z %}
      _km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
        }" MOVE={1 if printer.toolhead.homed_axes == 'xyz' else 0}
    {% endif %}
    {action_respond_info("Active bed surface: %s; offset: %.3f"
                        | format(SURFACE, surfaces.available[SURFACE].offset))}
  {% else %}
    {% set output = [] %}
    {% for s in surfaces.available|list|sort %}
      {% set dummy = output.append("%s&nbsp;%s - offset: %.3f" 
                      | format("*" if s == surfaces.active else "&nbsp;",
                                s, surfaces.available[s].offset)) %}
    {% endfor %}
    {action_respond_info(output|join('\n'))}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SURFACE|default(none) %}
  " %} # End argument block for Mainsail
[gcode_macro set_gcode_offset]
description: Wraps SET_GCODE_OFFSET to update the current bed sheet offset.
  Usage: SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>]
                          [Y=<pos>|Y_ADJUST=<adjust>]
                          [Z=<pos>|Z_ADJUST=<adjust>]
                          [MOVE=1 [MOVE_SPEED=<speed>]]
rename_existing: _KM_SET_GCODE_OFFSET_BASE
gcode:
  {% set surfaces = printer.save_variables.variables.bed_surfaces %}
  {% if surfaces.active and
        not printer["gcode_macro _km_save_state"].is_ephemeral %}
    {% set Z = params.Z|default(0.0)|float|round(6) %}
    {% set Z_ADJUST = params.Z_ADJUST|default(0.0)|float %}
    {% if 'Z' in params and
                 Z != surfaces.available[surfaces.active].offset %}
      {% set dummy = surfaces.available[surfaces.active].__setitem__("offset",
                       Z) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% elif Z_ADJUST != 0.0 %}
      {% set dummy = surfaces.available[surfaces.active].__setitem__(
        "offset", (Z_ADJUST + printer.gcode_move.homing_origin.z)|round(6)) %}
      SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
    {% endif %}
  {% endif %}
  _km_set_gcode_offset_base{% for k in params%}{' '~k~'="'~params[k]~'"'
    }{% endfor %}


    # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.
[gcode_macro m300]
description: Emits and audible beep.
  Usage: M300 [P<duration>] [S<frequency>]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if "output_pin beeper" in printer %}
    {% set P = params.P|default(km.beep_duration) %}
    {% set S = params.S|default(km.beep_frequency) %}
    SET_PIN PIN=beeper VALUE={S}
    G4 P{P}
    SET_PIN PIN=beeper VALUE=0
  {% else %}
    {action_respond_info(
       "M300 is disabled. To enable create an [output_pin beeper] config.")}
  {% endif %}

  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

# Sets optional scaling factor, minimum, and maximum applied to M106 commmand.
# If a MINIMUM greater than 0 is specified the fan will not stop unless an
# M107 command is issued. SET_FAN_SCALING always displays the current paramaters
# if scaling is active. SET_FAN_SCALING without any arguments will display the
# current scaling parameters without changing them.

[gcode_macro _check_fan_params]
gcode:
  {% set MAXIMUM = params.MAXIMUM|default(
      printer["gcode_macro set_fan_scaling"].maximum)|int %}
  {% set MINIMUM = params.MINIMUM|default(
      printer["gcode_macro set_fan_scaling"].minimum)|int %}

  {% if params.SCALE and params.SCALE|float <= 0 %}
    { action_raise_error("SCALE must be a positive value.") }
  {% elif MINIMUM < 0 or MINIMUM > 255 %}
    { action_raise_error("MINIMUM must be between 0 and 255.") }
  {% elif MAXIMUM < 0 or MAXIMUM > 255 %}
    { action_raise_error("MAXIMUM must be between 0 and 255.") }
  {% elif params.SPEED and (params.SPEED|int < 0 or params.SPEED|int > 255) %}
    { action_raise_error("SPEED must be between 0 and 255.") }
  {% elif params.BOOST and (params.BOOST|int < 0 or params.BOOST|int > 255) %}
    { action_raise_error("BOOST must be between 0 and 255.") }
  {% elif MINIMUM > MAXIMUM %}
    { action_raise_error("MINIMUM must be less than or equal to MAXIMUM.") }
  {% endif %}

[gcode_macro set_fan_scaling]
description: Sets fan scaling factors applied to M106 command. If a speed is
  provided it will be adjusted according to the scaling parameters.
  Usage: SET_FAN_SCALING [SCALE=<scale>] [BOOST=<boost>] [MAXIMUM=<max>]
                         [MINIMUM=<min>] [SPEED=<speed>]
variable_scale: 1.0
variable_boost: 0
variable_minimum: 0
variable_maximum: 255
variable_real_speed: 0
gcode:
  _CHECK_FAN_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
  {% set SCALE = params.SCALE|default(scale)|float %}
  {% set BOOST = params.BOOST|default(boost)|float %}
  {% set MAXIMUM = params.MAXIMUM|default(maximum)|int %}
  {% set MINIMUM = params.MINIMUM|default(minimum)|int %}
  {% set SPEED = params.SPEED|default(real_speed)|int %}

  {% if SCALE != 1.0 or BOOST != 0 or MAXIMUM != 255 or MINIMUM != 0 %}
    {action_respond_info("Fan: Scale: %.2f Minimum:%i Maximum: %i Speed: %i"|
                         format(SCALE, MINIMUM, MAXIMUM, SPEED))}
  {% endif %}

  # Update parameters on change.
  {% if params|length > 0 %}
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=scale VALUE="{SCALE}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=boost VALUE="{BOOST}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=minimum VALUE="{MINIMUM}"
    SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=maximum VALUE="{MAXIMUM}"
    # Run fan at adusted speed
    M106 S{SPEED}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0)|int %}
  {% set dummy = params.MAXIMUM|default(255)|int %}
  {% set dummy = params.MINIMUM|default(0)|int %}
  {% set dummy = params.SPEED|default(current speed)|int %}
  " %} # End argument block for Mainsail

[gcode_macro reset_fan_scaling]
description: Clears all fan scaling factors.
  Usage: RESET_FAN_SCALING
gcode:
  SET_FAN_SCALING SCALE=1.0 BOOST=0 MAXIMUM=255 MINIMUM=0

[gcode_macro m106]
description: Wraps M106 to implement scaling overrides.
rename_existing: M106.6245197
gcode:
  {% set S = params.S|default(255)|int %}
  {% if S > 255 or S < 0 %}
    { action_raise_error("S[%i] out of range.") | format(S) }
  {% endif %}

  {% set scale = printer["gcode_macro set_fan_scaling"] %}
  SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=real_speed VALUE="{S}"
  M106.6245197 S{((((S + scale.boost) * scale.scale) | round | int,
                   scale.minimum) | max, scale.maximum) | min}


                   # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _load_unload]
variable_is_printing: 1
gcode:
  # Klipper think we're printing if parking homed first, so this is a hack to
  # prevent that from happening. The caller sets the value and we clear it.
  SET_GCODE_VARIABLE MACRO=_load_unload VARIABLE=is_printing VALUE="{1}"
  {% set saved_extruder = printer.toolhead.extruder %}
  {% set EXTRUDER = params.EXTRUDER|default(saved_extruder)|lower %}
  {% if 'MINIMUM' in params %}
    {% set MINIMUM = params.MINIMUM %}
  # This is the special case for a filament change after an idle timeout.
  {% elif printer.pause_resume.is_paused and printer[EXTRUDER].target == 0 and
          printer["gcode_macro resume"].saved_extruder_temp %}
    {% set MINIMUM = printer["gcode_macro resume"].saved_extruder_temp %}
  {% else %}
    {% set MINIMUM =
             printer.configfile.settings[EXTRUDER].min_extrude_temp + 5.0 %}
  {% endif %}
  {% if MINIMUM < printer.configfile.settings[EXTRUDER].min_extrude_temp %}
    { action_raise_error("Extrude below minimum temp.") }
  {% elif printer.pause_resume.is_paused %}
    # Clear the saved E if we're (un-)loading while paused.
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{0.0}"
  {% elif printer.idle_timeout.state == "Printing" and is_printing %}
    { action_raise_error("Command not valid during printing.") }
  {% endif %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set SPEED = params.SPEED|default(km.load_speed) %}
  {% set priming_length = km.load_priming_length %}
  {% set LENGTH = params.LENGTH|default(km.load_length)|float - priming_length%}
  {% if LENGTH < 0 %}
    {% set priming_length = (priming_length + LENGTH, 0)|max %}
    {% set LENGTH = 0 %}
  {% endif %}
  SAVE_GCODE_STATE NAME=_LOAD_UNLOAD
  {% if EXTRUDER != saved_extruder%}
    ACTIVATE_EXTRUDER EXTRUDER={EXTRUDER}
  {% endif %}
  {% if printer[EXTRUDER].target < MINIMUM %}
    M109 S{MINIMUM}
  {% endif %}
  M83
  {% if params.LOAD|int %}
    G1 E{LENGTH} F{SPEED}
    G1 E{priming_length} F{(km.load_priming_speed, SPEED)|min}
    G1 E{'%.4f' % -printer["gcode_macro resume"].saved_e} F{km.load_speed}
  {% else %}
    G1 E3.0 F{SPEED}
    G4 P500
    G1 E{'%.4f' % -priming_length} F{(km.load_priming_speed, SPEED)|min}
    G1 E{'%.4f' % -LENGTH} F{SPEED}
  {% endif %}
  RESTORE_GCODE_STATE NAME=_LOAD_UNLOAD

[gcode_macro load_filament]
description: Loads filament to the extruder.
  Usage: LOAD_FILAMENT [LENGTH=<distance>] [SPEED=<speed>]
                       [EXTRUDER=<extruder>] [MINIMUM=<temperature>]
gcode:
  _LOAD_UNLOAD LOAD=1{% for k in params
    %}{' '~k~'="'~params[k]~'"'}{% endfor %}

  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LENGTH|default(variable_load_length)|float %}
  {% set dummy = params.SPEED|default(variable_load_speed)|float %}
  {% set dummy = params.EXTRUDER|default(current extruder) %}
  {% set dummy = params.MINIMUM|default(min_extrude_temp)|int %}
  " %} # End argument block for Mainsail

[gcode_macro unload_filament]
description: Unloads filament from the extruder.
  Usage: UNLOAD_FILAMENT [LENGTH=<distance>] [SPEED=<speed>]
                         [EXTRUDER=<extruder>] [MINIMUM=<temperature>]
gcode:
  _LOAD_UNLOAD LOAD=0{% for k in params
    %}{' '~k~'="'~params[k]~'"'}{% endfor %}

  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LENGTH|default(variable_load_length)|float %}
  {% set dummy = params.SPEED|default(variable_load_speed)|float %}
  {% set dummy = params.EXTRUDER|default(default extruder) %}
  {% set dummy = params.MINIMUM|default(min_extrude_temp)|int %}
  " %} # End argument block for Mainsail

[gcode_macro _pause_inner_m700]
gcode:
  {% set extruder = printer["extruder" ~ params.T|int]
     if params.T|default(0)|int != 0 else printer.toolhead.extruder %}
  {% if extruder != printer.toolhead.extruder%}
    ACTIVATE_EXTRUDER EXTRUDER={extruder}
  {% endif %}

  {% set z_param = (' Z="%f"' % params.Z) if 'Z' in params else "" %}

  {% if printer.idle_timeout.state|string == "Printing" %}
    PAUSE P=2{z_param}
  {% elif not printer.pause_resume.is_paused%}
    SET_GCODE_VARIABLE MACRO=_load_unload VARIABLE=is_printing VALUE="{0}"
    PARK P=2{z_param}
  {% endif %}

[gcode_macro m701]
description: Pauses/parks the toolhead then loads filament to the extruder.
  Usage: M701 [L<distance>] [Z<pos>] [T<extruder>]
gcode:
  {% if 'U' in params %}
    {% if not 'L' in params %}
      RESPOND TYPE=error MSG="Argument \"U\" substituted for missing \"L\"."
      {% set dummy = params.__setitem__("L", params.U) %}
    {% else %}
      RESPOND TYPE=error MSG="Invalid argument \"U\" ignored."
    {% endif %}
  {% endif %}

  _PAUSE_INNER_M700 {% for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  LOAD_FILAMENT LENGTH={
    params.L|default(printer["gcode_macro _km_globals"].load_length)|float}

[gcode_macro m702]
description: Pauses/parks the toolhead then unloads filament from the extruder.
  Usage: M702 [U<distance>] [Z<pos>] [T<extruder>]
gcode:
  {% if 'L' in params %}
    {% if not 'U' in params %}
      RESPOND TYPE=error MSG="Argument \"L\" substituted for missing \"U\"."
      {% set dummy = params.__setitem__("U", params.L) %}
    {% else %}
      RESPOND TYPE=error MSG="Invalid argument \"L\" ignored."
    {% endif %}
  {% endif %}

  _PAUSE_INNER_M700 {% for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
  UNLOAD_FILAMENT LENGTH={
    params.U|default(printer["gcode_macro _km_globals"].load_length)|float}


    # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

################################################################################
#
# Declare any of the below variables in your own [gcode_macro _km_options] to
# to override the values here. Don't change them in this file (or things may
# break). See README.md for more information.
#
################################################################################
[gcode_macro _km_globals]
# Available bed surfaces for offset adjustments.
variable_bed_surface_max_name_length: 10
# Available bed surfaces for offset adjustments.
variable_bed_surfaces: []
# Default beep frequency (in Hz) for M300 command.
variable_beep_frequency: 1000
# Default beep duration (in ms) for M300 command.
variable_beep_duration: 100
# Length (in mm) of filament to load (bowden tubes will be longer).
variable_load_length: 90.0
# Filament loading speed (in mm/m).
variable_load_speed: 300
# Length (in mm) of the filament loading that feeds at priming speed.
variable_load_priming_length: 25.0
# Filament priming speed (in mm/m).
variable_load_priming_speed: 150
# Set to 0 to hide the Octoprint LCD menus.
variable_menu_show_octoprint: 1
# Set to 0 to hide the SD Card LCD menus.
variable_menu_show_sdcard: 1
# List up to 10 pre-heat settings in order for the LCD "Temperature" menu
variable_menu_temperature: [
  {'name' : 'PLA',  'extruder' : 200, 'bed' : 60},
  {'name' : 'PETG', 'extruder' : 230, 'bed' : 85},
  {'name' : 'ABS',  'extruder' : 245, 'bed' : 110}]
# X position to park the toolhead.
variable_park_x: 0.0
# Y position to park the toolhead.
variable_park_y: 0.0
# Z position to park the toolhead.
variable_park_z: 20.0
# Scaling factor for M900 command (negative values make M900 a no-op).
variable_pressure_advance_scale: -1.0
# Additional padding around the specified print area for a bed mesh.
variable_probe_mesh_padding : 5.0
# Minimum number of probes for partial probing of a bed mesh.
variable_probe_min_count: 3
# Scaling factor to increase probe count for partial bed probes.
variable_probe_count_scale: 1.0
# Extruder scale factor during pre-warmup in PRINT_START.
variable_start_extruder_preheat_scale: 0.5
# Additional delay (in ms) during bed heating, to allow the bed to stabilize.
variable_start_bed_heat_delay: 2000
# Amount (in degrees C) to overshoot bed target temp before stabilizing.
variable_start_bed_heat_overshoot: 2.0
# Set 1 to level bed in PRINT_START after stabilizing at temp; set 0 to disable.
variable_start_level_bed_at_temp: 1
# Set 1 to clear adjustments (e.g. feedrate, extrusion, heater) at end of print.
variable_start_clear_adjustments_at_end: 1
# X and Y travel speed (in mm/m) for movement macros.
variable_travel_speed_xy: 3000
# Z travel speed in (mm/m) for movement macros.
variable_travel_speed_z: 600
# Value to scale acceleration by when setting ACCEL_TO_DECEL in M204, etc.
variable_velocity_decel_scale: 0.5
################################################################################
description: Initializes our globals, including any _km_options overrides.
gcode:
  # Doing a shutdown here is a bit aggressive, but if we're missing required
  # sections then a lot of things could go very bad later.
  # To minimize the annoyance we try to identify all the fatal errors at once.
  # format is:
  #   key = required config section
  #   value[0] = required field in section
  #   value[1] = required string in field
  #   A "None" value means there's no required field
  {% set required_sections = {"heater_bed" : None,
                              "extruder" : None,
                              "gcode_macro _km_options" : None,
                              "idle_timeout" : ("gcode", "_KM_IDLE_TIMEOUT"),
                              "pause_resume" : None,
                              "respond" : None,
                              "save_variables" : None,
                              "virtual_sdcard" : None
                             } %}
  {% set output = [] %}
  {% for s in required_sections %}
    {% set f = required_sections[s][0] if required_sections[s] else None %}
    {% set v = required_sections[s][1] if required_sections[s] else None %}
    {% if s not in printer.configfile.config %}
      {% set dummy = output.append("Missing [%s] section.\n" | format(s)) %}
    {% elif f and
            (v not in printer.configfile.config[s][f]|default("")|upper) %}
      {% set dummy = output.append("Missing %s in %s for [%s] section.\n"
                                   | format(v, f, s)) %}
    {% endif %}
  {% endfor %}
  {% if output %}
    { action_emergency_stop(
        "required printer.cfg section(s) missing:\n"
        ~ output | join("\n")) ~
        "See readme: https://github.com/jschuh/" }
  {% endif %}

  # Bed leveling behavior is based on config options.
  SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_level_bed_at_temp VALUE="{
    1 if printer.bed_mesh is defined else 0}"
  BED_MESH_CHECK

  {% set options = printer["gcode_macro _km_options"] %}
  {% set km = printer["gcode_macro _km_globals"] %}
  # Force overrides to use the original types in _KM_GLOBALS.
  {% for k in options %}
    {% if k not in km %}
      {action_raise_error("%s is not valid for _KM_OPTIONS." | format(k))}
    {% endif %}
    {% if km[k] is string %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="'{options[k]|replace('\\','\\\\')|replace('\'','\\\'')
                             |replace('\"','\\\"')}'"
    {% elif km[k] is float %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="{options[k]|float}"
    {% elif km[k] is integer %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k} VALUE="{options[k]|int}"
    {% elif km[k] is mapping %}
      {% if options[k] is not mapping %}
        {action_raise_error("%s requires a mapping type." | format(k))}
      {% endif %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="{options[k]|replace('\"','\\\"')}"
    {% elif km[k] is sequence %}
      {% if options[k] is not sequence %}
        {action_raise_error("%s requires a sequence type." | format(k))}
      {% endif %}
      SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
        } VALUE="{options[k]|replace('\"','\\\"')}"
    {% else %}
      {action_raise_error("%s is not a valid type for _KM_OPTIONS."|format(k))}
    {% endif %}
  {% endfor %}
  M400

[delayed_gcode INIT_GLOBALS]
# This runs once at startup and initializes all macros.
initial_duration: 0.0001
gcode:
  _KM_GLOBALS
  # This needs to be its own macro so it gets evaluated after _KM_GLOBALS runs.
  _CHECK_GLOBALS
  _INIT_SURFACES
  # This is any end-user gcode that need to run after macro initialization.
  _KM_OPTIONS

[gcode_macro _check_globals]
description: Checks global variables and stops printer on an invalid value.
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set toolhead = printer.toolhead %}
  {% set output = [] %}
  {% if km.park_x > toolhead.axis_maximum.x or
        km.park_x < toolhead.axis_minimum.x %}
    {% set dummy = output.append("park_x is invalid.") %}
  {% endif %}
  {% if km.park_y > toolhead.axis_maximum.y or
        km.park_y < toolhead.axis_minimum.y %}
    {% set dummy = output.append("park_y is invalid.") %}
  {% endif %}
  {% if km.park_z > toolhead.axis_maximum.z or
        km.park_z < toolhead.axis_minimum.z %}
    {% set dummy = output.append("park_z is invalid.") %}
  {% endif %}
  {% if km.start_extruder_preheat_scale > 1.0 or
        km.start_extruder_preheat_scale < 0.0 %}
    {% set dummy = output.append("extruder_preheat_scale is invalid.") %}
  {% endif %}
  {% if km.load_length > 
        printer.configfile.settings["extruder"].max_extrude_only_distance %}
    {% set dummy = output.append(
      "load_length exceeds max_extrude_only_distance.") %}
  {% endif %}
  {% if km.load_length < km.load_priming_length %}
    {% set dummy = output.append(
      "load_length is shorter than load_priming_length.") %}
  {% endif %}
  {% if km.load_length < 0.0 %}
    {% set dummy = output.append("load_length is negative.") %}
  {% endif %}
  {% if km.load_priming_length < 0.0 %}
    {% set dummy = output.append("load_priming_length is negative.") %}
  {% endif %}

  # Emit all the config errors.
  {% if output %}
    { action_raise_error(output|sort|join('\n')) }
  {% endif %}
  M400

[gcode_macro kmvars]
description: Lists global variables used by klipper-macros.
  Usage: KMVARS [SEARCH=<search_string>]
gcode:
  {% set SEARCH = params.SEARCH|default(params.S|default(""))|lower %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set output = [] %}
  {% for k in km %}
    {% if SEARCH in k %}
      {% set dummy = output.append(k ~ ": " ~ km[k]) %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output|sort|join('\n')) }

[gcode_macro check_macro_docs]
description: Lists macros lacking proper documentation.
  Usage: CHECK_MACRO_DOCS [USAGE=<0|1>] [HIDDEN=<1|0>] [RENAMED=<1|0>]
gcode:
  {% set USAGE = params.USAGE|default(0)|int %}
  {% set HIDDEN = params.HIDDEN|default(0)|int %}
  {% set RENAMED = params.RENAMED|default(0)|int %}
  {% set output = [] %}
  {%set config = printer.configfile.config %}
  {% for k in config|sort %}
    {% if k.startswith("gcode_macro") %}
      {% set name = k.split()[1] %}
      {% set desc = config[k].description|default("") %}
      {% set is_renamed = config[k].rename_existing|default("") %}
      {% if (not desc or (USAGE and not "Usage: "~name.upper() in desc)) and
             (HIDDEN or not name.startswith('_')) and (RENAMED or is_renamed) %}
        {% set dummy = output.append("%s&nbsp;%s: missing %s."
           | format("*" if is_renamed else "&nbsp;", name,
                    "description" if not desc else "usage")) %}
      {% endif %}
    {% endif %}
  {% endfor %}
  {action_respond_info(output|join("\n"))}

# The below macro is a lightly edited version of the one found here:
# https://klipper.discourse.group/t/example-search-printer-objects/164
[gcode_macro listvars]
description: Lists per-macro variables with a name containing SEARCH. This is 
  useful for debugging macros by allowing you to probe printer state. Be very
  careful, however, as an overly broad SEARCH parameter can take a long time
  to process and potentially hang or crash klipper.
  Usage: LISTVARS SEARCH=<search_string>
gcode:

  {% if 'SEARCH' not in params and 'S' not in params %}
    { action_raise_error("Must provide a SEARCH parameter.") }
  {% endif %}
  {% set SEARCH = params.SEARCH|default(params.S)|lower %}
  {% set ns = namespace() %}
  {% set output = [] %}
  {% for item in printer %}
    {% if ' ' in item %}
      {% set ns.path = ['printer', "['%s']" % (item), ''] %}
    {% else %}
      {% set ns.path = ['printer.', item, ''] %}
    {% endif %}

    {% if SEARCH in ns.path|lower %}
      {% set dummy = output.append(ns.path|join) %}
    {% endif %}

    {% if printer[item].items() %}
      {% for childkey, child in printer[item].items() recursive %}
          {% set ns.path = ns.path[:loop.depth|int + 1] %}
          {% if ' ' in childkey %}
            {% set null = ns.path.append("['%s']" % (childkey)) %}
          {% else %}
            {% set null = ns.path.append(".%s" % (childkey)) %}
          {% endif %}

          {% if child is mapping  %}
            {loop(child.items())}
          {% else %}
            {% if SEARCH in ns.path|lower %}
              {% set dummy = output.append("%s : %s" % (ns.path|join, child)) %}
            {% endif %}
          {% endif %}
        {% endfor %}
    {% endif %}
  {% endfor %}
  { action_respond_info(output|join("\n")) }


  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro set_heater_temperature_scaled]
gcode:
  {% set HEATER = params.HEATER.lower() %}
  {% set TARGET = params.TARGET|default(0.0)|float %}
  {% set scaled_heaters =
           printer["gcode_macro set_heater_scaling"].scaled_heaters %}
  {% if HEATER in scaled_heaters %}
    {% set scales = scaled_heaters[HEATER] %}
    {% set dummy = scales.__setitem__("real_target", TARGET) %}
    {%if TARGET > 0.0 %}
      {% set TARGET = (((TARGET + scales.bump) * scales.scale, scales.minimum)
                       | max, scales.maximum)|min %}
    {% endif %}
  {% endif %}
  SET_HEATER_TEMPERATURE HEATER="{HEATER}" TARGET={TARGET}

[gcode_macro temperature_wait_scaled]
gcode:
  {% set SENSOR = params.SENSOR.lower() %}
  {% set heater = SENSOR if not SENSOR.startswith("heater_generic") else
                  SENSOR.split()[1] %}
  {% set scaled_heaters =
           printer["gcode_macro set_heater_scaling"].scaled_heaters %}
  {% if heater in scaled_heaters %}
    {% set scales = scaled_heaters[heater] %}
    {% if "MINIMUM" in params and MINIMUM > 0.0 %}
      {% set MINIMUM = (((MINIMUM + scales.bump) * scales.scale, scales.minimum)
                        | max, scales.maximum)|min %}
    {% endif %}
    {% if "MAXIMUM" in params and MINIMUM > 0.0 %}
      {% set MAXIMUM = (((MAXIMUM + scales.bump) * scales.scale, scales.minimum)
                        | max, scales.maximum)|min %}
    {% endif %}
  {% else %}
    {% set settings = printer.configfile.settings[SENSOR] %}
    {% set MINIMUM = params.MINIMUM|default(settings.min_temp) %}
    {% set MAXIMUM = params.MAXIMUM|default(settings.max_temp) %}
  {% endif %}
  {% if printer[sensor].temperature < MINIMUM or
        printer[sensor].temperature > MAXIMUM %}
    TEMPERATURE_WAIT SENSOR="{SENSOR}" MINIMUM={MINIMUM} MAXIMUM={MAXIMUM}
  {% endif %}

[gcode_macro _gcode_wait_wrapper_inner]
gcode:
  # Macro variables are evaluated at instantiation, so this inner macro is what
  # gets us a scaled target value.
  {% set sensor = params.HEATER if params.HEATER in
       printer.heaters.available_heaters 
     else ("heater_generic " ~ params.HEATER) %}
  {% set target = printer[sensor].target %}
  {% if 'R' in params and target > 0.0 %}
    {% set T = params.T|default("") %}
    M{params.M}.6245197 S{target} { (" T"~T) if T else "" }
  {% elif printer[sensor].temperature < target %}
    TEMPERATURE_WAIT SENSOR="{sensor}" MINIMUM={target}
  {% endif %}

[gcode_macro _gcode_wait_wrapper]
gcode:
  {% set target = params.S | default(params.R | default(0))| float %}
  SET_HEATER_TEMPERATURE_SCALED HEATER="{params.HEATER}" TARGET={target}
  _GCODE_WAIT_WRAPPER_INNER{%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}

[gcode_macro m109]
rename_existing: M109.6245197
gcode:
  {% set extruder = printer["extruder" ~ params.T]
     if params.T|default(0)|int != 0 else printer.toolhead.extruder %}
  _GCODE_WAIT_WRAPPER HEATER={extruder}{%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}

[gcode_macro m190]
rename_existing: M190.6245197
gcode:
  _GCODE_WAIT_WRAPPER HEATER=heater_bed {%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}

[gcode_macro m191]
description: Sets chamber temperature (with wait for heating).
  Usage: M191 [S<temp>]
gcode:
  # Just fake the R parameter for the chamber.
  {% if "R" in params %}
    {% set dummy = params.__setitem__("S", params.R) %}
  {% endif %}
  _GCODE_WAIT_WRAPPER HEATER=chamber {%
    for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}

[gcode_macro m104]
rename_existing: M104.6245197
gcode:
  {% set extruder = printer["extruder" ~ params.T]
     if params.T|default(0)|int != 0 else printer.toolhead.extruder %}
  SET_HEATER_TEMPERATURE_SCALED HEATER={extruder} TARGET={params.S|default(0)}

[gcode_macro m140]
rename_existing: M140.6245197
gcode:
  SET_HEATER_TEMPERATURE_SCALED HEATER=heater_bed TARGET={params.S|default(0)}

[gcode_macro m141]
description: Sets chamber temperature.
  Usage: M141 [S<temp>]
gcode:
  SET_HEATER_TEMPERATURE_SCALED HEATER=chamber TARGET={params.S|default(0)}

[gcode_macro _check_heater_params]
gcode:
  {% set HEATER = params.HEATER|lower %}
  {% set sensor = params.HEATER %}
  {% if HEATER not in printer.heaters.available_heaters %}
    {% set sensor = "heater_generic " ~ HEATER %}
    {% if sensor not in printer.heaters.available_heaters %}
      { action_raise_error("The value '%s' is not valid for HEATER"
                            | format(HEATER)) }
    {% endif %}
  {% endif %}
  {% set settings = printer.configfile.settings[sensor] %}
  {% set scaled_heaters =
       printer["gcode_macro set_heater_scaling"].scaled_heaters %}
  {% if HEATER is in scaled_heaters %}
    {% set scales = scaled_heaters[HEATER] %}
  {% else %}
    {% set scales = { "scale": 1.0, "bump": 0.0, "minimum": settings.min_temp,
                      "maximum": settings.max_temp,
                      "real_target": printer[sensor].target} %}
  {% endif %}
  {% set SCALE = params.SCALE|default(scales.scale)|float %}
  {% set BUMP = params.BUMP|default(scales.bump)|float %}
  {% set MINIMUM = params.MINIMUM|default(scales.minimum)|float %}
  {% set MAXIMUM = params.MAXIMUM|default(scales.maximum)|float %}

  {% if SCALE <= 0 %}
    { action_raise_error("SCALE must be a positive value.") }
  {% elif MINIMUM < settings.min_temp or MINIMUM > settings.max_temp %}
    { action_raise_error("MINIMUM must be between %.1f and %.1f" |
      format(settings.min_temp, settings.max_temp)) }
  {% elif MAXIMUM < settings.min_temp or MAXIMUM > settings.max_temp %}
    { action_raise_error("MAXIMUM must be between %.1f and %.1f" |
      format(settings.min_temp, settings.max_temp)) }
  {% elif MINIMUM >= MAXIMUM %}
    { action_raise_error("MINIMUM must be less than MAXIMUM.") }
  {% elif "TARGET" in params and (params.TARGET|float < MINIMUM or
                                  params.TARGET|float > MAXIMUM) %}
    { action_raise_error("TARGET must be between %.1f and %.1f" |
      format(settings.min_temp, settings.max_temp)) }
  {% endif %}

[gcode_macro set_heater_scaling]
description: Sets scaling parameters for heater. If a new target temperature is
  passed it will be adjusted to the scaling parameters.
  Usage: SET_HEATER_SCALING [HEATER=<heater>] [SCALE=<scale_factor>]
                            [BUMP=<degrees>] [MAXIMUM=<degrees>]
                            [MINIMUM=<degrees>] [TARGET=<temp>]
variable_scaled_heaters: {}
gcode:
  # If no heater is supplied just list out all the scaled heaters.
  {% if "HEATER" is not in params %}
    {% set output = [] %}
    {% for h in scaled_heaters %}
      {% set dummy = output.append(
         "%s: Scale: %.2f Bump: %.1f Minimum:%.1f Maximum: %.1f"
         | format(h, scaled_heaters[h].scale, scaled_heaters[h].bump,
                  scaled_heaters[h].minimum, scaled_heaters[h].maximum)) %}
    {% endfor %}
    {% if output %}}{action_respond_info(output|join('\n'))}{% endif %}
  {% else %}
    # See if we need a new scaling entry for this heater.
    {% set HEATER = params.HEATER.lower() %}
    {% set settings = printer.configfile.settings[HEATER] %}
    {% if HEATER is not in scaled_heaters %}
      {% set dummy = scaled_heaters.__setitem__(HEATER, {"scale": 1.0,
         "bump": 0.0, "minimum": settings.min_temp,
         "maximum": settings.max_temp,
         "real_target": printer[HEATER].target}) %}
    {% endif %}
    _CHECK_HEATER_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
    {% set scales = scaled_heaters[HEATER] %}
    {% set SCALE = params.SCALE|default(scales.scale)|float %}
    {% set BUMP = params.BUMP|default(scales.bump)|float %}
    {% set MAXIMUM = params.MAXIMUM|default(scales.maximum)|float %}
    {% set MINIMUM = params.MINIMUM|default(scales.minimum)|float %}
    {% set TARGET = params.TARGET|default(scales.real_target)|float %}
    {% set dummy = scales.__setitem__("scale", SCALE) %}
    {% set dummy = scales.__setitem__("bump", BUMP) %}
    {% set dummy = scales.__setitem__("maximum", MAXIMUM) %}
    {% set dummy = scales.__setitem__("minimum", MINIMUM) %}
    {% set dummy = scales.__setitem__("real_target", TARGET) %}

    {% set settings = printer.configfile.settings[HEATER] %}
    {% if SCALE != 1.0 or BUMP != 0.0 or MINIMUM != settings.min_temp or
          MAXIMUM != settings.max_temp %}
      {% set dummy = scaled_heaters.__setitem__(HEATER, scales) %}
    {% else %} # Remove a redundant scaling entry.
      {% set dummy = scaled_heaters.__delitem__(HEATER) %}
    {% endif %}
    SET_HEATER_TEMPERATURE_SCALED HEATER={HEATER} TARGET={TARGET}
    {action_respond_info(
       "%s: Scale: %.2f Bump: %.1f Minimum:%.1f Maximum: %.1f Target: %.1f"
       | format(HEATER, SCALE, BUMP, MINIMUM, MAXIMUM, TARGET))}
  {% endif %}
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.HEATER|default(e.g. extruder) %}
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0.0)|float %}
  {% set dummy = params.MAXIMUM|default(max_temp)|float %}
  {% set dummy = params.MINIMUM|default(min_temp)|float %}
  {% set dummy = params.TARGET|default(current target)|float %}
  " %} # End argument block for Mainsail

[gcode_macro reset_heater_scaling]
description: Clears scaling for heater (or all heaters if none specified).
  Usage: RESET_HEATER_SCALING [HEATER=<heater>]
gcode:
  {% if "HEATER" in params %}
    {% set HEATER = params.HEATER.lower() %}
    {% if HEATER not in printer.heaters.available_heaters %}
      { action_raise_error("The value '%s' is not valid for HEATER"
                           | format(HEATER)) }
    {% endif %}
    {% set settings = printer.configfile.settings[HEATER] %}
    SET_HEATER_SCALING HEATER={HEATER
                     } SCALE=1.0 BUMP=0.0 MINIMUM={settings.min_temp
                     } MAXIMUM={settings.max_temp}
  {% else %}
    # Clear everything if no heater was provided.
    SET_GCODE_VARIABLE MACRO=set_heater_scaling VARIABLE=scaled_heaters VALUE={
      "{}"}
  {% endif %}


  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _km_idle_timeout]
gcode:
  {% if printer.pause_resume.is_paused %}
    {action_respond_info("Extruder powered down on idle timeout.")}
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{
      printer[printer.toolhead.extruder].target}"
    M104; Turn off extruder but leave the bed on.
  {% else %}
    TURN_OFF_HEATERS
    M107; turn off fan
    M84
  {% endif %}

  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _check_kinematic_limits]
gcode:
  {% set toolhead = printer.toolhead %}
  {% if params.X and (params.X|float < toolhead.axis_minimum.x or
                      params.X|float > toolhead.axis_maximum.x) %}
    {action_raise_error("X[%.3f] must be between %.3f and %.3f."
                        | format(params.X|float, toolhead.axis_minimum.x,
                                 toolhead.axis_maximum.x))}
  {% elif params.Y and (params.Y|float < toolhead.axis_minimum.y or
                        params.Y|float > toolhead.axis_maximum.y) %}
    {action_raise_error("Y[%.3f] must be between %.3f and %.3f."
                        | format(params.Y|float, toolhead.axis_minimum.y,
                                 toolhead.axis_maximum.y))}
  {% elif params.Z and (params.Z|float < toolhead.axis_minimum.z or
                        params.Z|float > toolhead.axis_maximum.z) %}
    {action_raise_error("Z[%.3f] must be between %.3f and %.3f."
                        | format(params.Z|float, toolhead.axis_minimum.z,
                                 toolhead.axis_maximum.z))}
  {% elif params.E and (params.E|float|abs > printer.configfile.settings[
                          "extruder"].max_extrude_only_distance) %}
    {action_raise_error("E[%.4f] exceeds max_extrude_only_distance[%.4f]."
       | format(params.E|float|abs, printer.configfile.settings[
                                      "extruder"].max_extrude_only_distance))}
  {% endif %}

[gcode_macro g28]
description: Wraps the G28 command to add the Marlin "O" parameter so that
  already homed axes will not be homed again. See the Klipper documentation on
  G28 for the behavior of the other parameters.
  Usage: G28 [O] ...
rename_existing: G28.6245197
gcode:
  {% set do_homing = True %}
  {% if 'O' in params %}
    # No axes means home them all, so add the list in before pruning.
    {% if params|select('in', 'XYZ')|list|length == 0 %}
      {% for k in 'XYZ' %}
        {% set dummy = params.__setitem__(k, '') %}
      {% endfor %}
    {% endif %}
    # Prune out the already homed axes.
    {% for k in params|select('in', 'XYZ')|list %}
      {% if k|lower in printer.toolhead.homed_axes %}
        {% set dummy = params.__delitem__(k) %}
      {% endif %}
    {% endfor %}
    {% set dummy = params.__delitem__('O') %}
    # If we don't have anything left we can skip homing.
    {% set do_homing = params|select('in', 'XYZ')|list|length > 0 %}
  {% else %}
  {% endif %}

  {% if do_homing %}
    G28.6245197{% for k in params %}{' ' ~ k ~ params[k]}{% endfor %}
  {% endif %}

  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro before_layer_change]
description: Add this to the "before layer change" input box in the slicer.
  Usage: BEFORE_LAYER_CHANGE HEIGHT=<current_height> LAYER=<current_layer>
gcode:
  {% set height = params.HEIGHT|default(printer.toolhead.position.z)|float %}
  {% set layer = params.LAYER|default(-1)|int + 1 %}
  {% if height >= 0.0 %}
    SET_PRINT_STATS_INFO CURRENT_LAYER="{layer}"
    SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{height}"
    {% if printer["gcode_macro _km_layer_run"].clearance_z < height %}
      SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{
        height}"
    {% endif %}
  {% endif %}
  _KM_LAYER_RUN BEFORE=1

[gcode_macro after_layer_change]
description: Add this to the "after layer change" input box in the slicer.
  Usage: AFTER_LAYER_CHANGE
gcode:
  _KM_LAYER_RUN BEFORE=0

[gcode_macro gcode_at_layer]
description: Schedules the specified g-code command to be run at the specified
  layer. LAYER=next will cause the command to run at the next layer change. 
  Usage: GCODE_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } COMMAND=<gcode> 
                         [BEFORE=<0|1>] [ALLOW_DUPLICATE=<0|1>]
gcode:
  {% set commands = printer["gcode_macro _km_layer_run"].commands %}
  {% set tot_layers = printer.print_stats.info.total_layer %}
  {% if params|length > 0 %}
    {% if not printer.pause_resume.is_paused and
          printer.idle_timeout.state|string != "Printing" %}
      {action_raise_error("No active print.")}
    {% endif %}

    {% set when = "before" if (params.BEFORE|default(0)|int) else "after" %}

    {% if "LAYER" in params %}
      {% set cur_layer = printer.print_stats.info.current_layer %}
      {% if "HEIGHT" in params %}
        {action_raise_error("Conflicting HEIGHT and LAYER arguments provided.")}
      {% elif params.LAYER|string|lower == "next" %}
        {% set LAYER = cur_layer + 1 %}
      {% else %}
        {% set LAYER = params.LAYER|int %}
      {% endif %}
      {% if LAYER <= cur_layer %}
        {action_raise_error("LAYER[%i] must be above current print layer[%i]."
                            | format(LAYER, cur_layer))}
      {% elif tot_layers and LAYER >= tot_layers %}
        {action_raise_error("LAYER[%i] must be below top layer[%i]."
                            | format(LAYER, tot_layers))}
      {% endif %}
      {% set key = "%12i_layer_%s"|format(LAYER, when)%}

    {% elif "HEIGHT" in params %}
      {% set HEIGHT = params.HEIGHT|float %}
      {% set cur_height = printer["gcode_macro _km_layer_run"].cur_height %}
      {% if HEIGHT <= cur_height %}
        {action_raise_error(
          "HEIGHT[%.3f] must be above current print height[%.3f].")
          | format(HEIGHT, cur_height)}
      {% elif HEIGHT >= printer.toolhead.axis_maximum.z %}
        {action_raise_error(
          "HEIGHT[%.3f] must be below maximum Z height[%.3f].")
          | format(HEIGHT, printer.toolhead.axis_maximum.z)}
      {% endif %}
      {% set key = "%12.3f_height_%s"|format(HEIGHT, when)%}

    {% else %}
      {action_raise_error("No HEIGHT or LAYER argument provided.")}
    {% endif %}
  
    {% set COMMAND = params.COMMAND %}
    {% if key not in commands %}
      {% set dummy = commands.__setitem__(key, []) %}
    {% endif %}
    {% if COMMAND in commands[key] or params.ALLOW_DUPLICATE|default(0)|int %}
      {action_raise_error("Duplicate command previously scheduled.")}
    {% else %}
      {% set dummy = commands[key].append(COMMAND) %}
      SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands VALUE="{
          commands|replace('\"','\\\"')}"
      {% set args = key.split('_') %}
      {% set pos = ("%i"|format(args[0]|int)) if args[1] == "layer" else
                   ("%.3fmm"|format(args[0]|float)) %}
      {action_respond_info("%s %s (%s):\n* %s" |
                           format(args[1], pos, args[2], COMMAND))}
    {% endif %}

  # No arguments means just list all the triggers.
  {% else %}
    {% set layers = [] %}
    {% set heights = [] %}
    {% for k in commands|list|sort %}
      {% set args = k.split('_') %}
      {% if args[1] == "layer" %}
        {% set dummy = layers.append("layer %i (%s):"
                                     | format(args[0]|int, args[2])) %}
        {% for c in commands[k] %}
          {% set dummy = layers.append("* %s" | format(c)) %}
        {% endfor %}
      {% else %}
        {% set dummy = heights.append("height %.3fmm (%s):"
                                      | format(args[0]|float, args[2])) %}
        {% for c in commands[k] %}
          {% set dummy = heights.append("* %s" | format(c)) %}
        {% endfor %}
      {% endif %}
    {% endfor %}
    {% set dummy = layers.extend(heights) %}
    {action_respond_info(layers|join('\n'))}
  {% endif %}

[gcode_macro init_layer_gcode]
description: Clears scheduled gcode commands and state for all layers.
  Usage: INIT_LAYER_GCODE LAYERS=<num>
gcode:
  SET_PRINT_STATS_INFO TOTAL_LAYER="{params.LAYERS|int}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands VALUE="{{}}"

[gcode_macro _reset_layer_gcode]
description: Clears scheduled gcode commands and state for all layers.
  Usage: _RESET_LAYER_GCODE
gcode:
  SET_PRINT_STATS_INFO TOTAL_LAYER="0"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands VALUE="{{}}"

[gcode_macro cancel_all_layer_gcode]
description: Clears all scheduled gcode commands.
  Usage: CANCEL_ALL_LAYER_GCODE
gcode:
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands VALUE="{{}}"

[gcode_macro pause_next_layer]
description: Convenience macro to schedule the current print to pause at the
  next layer change. See PAUSE for additional arguments.
  Usage: PAUSE_NEXT_LAYER ...
gcode:
  _CHECK_KINEMATIC_LIMITS{% for k in params%}{' ' ~k~ '=' ~ params[k]
    }{% endfor %}
  GCODE_AT_LAYER LAYER=NEXT COMMAND="PAUSE{% for k in params %}{
    ' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro _km_layer_run]
description: Runs pending commands for the current layer change.
  Usage: _KM_LAYER_RUN BEFORE=<0|1>
variable_cur_height: 0.0
variable_clearance_z: 0.0
variable_commands: {}
gcode:
  {% set BEFORE = params.BEFORE|int %}
  {% set cur_layer = printer.print_stats.info.current_layer %}
  {% for k in commands | list | sort %}
    {% set args = k.split('_') %}
    {% set cmd_pos = args[0]|float %}
    {% set cmd_type = args[1] %}
    {% set cmd_before = 1 if args[2] == "before" else 0 %}
    {% if cmd_before == BEFORE and (
         (cmd_type == "layer" and cmd_pos|int <= cur_layer) or
         (cmd_type == "height" and cmd_pos <= cur_height)) %}
      {action_respond_info("Executing scheduled commands at %s %s:\n%s" |
         format(args[1], args[0].strip(), commands[k]|join('\n')))}
      {% for c in commands[k] %}
        {c}
      {% endfor %}
      {% set dummy = commands.__delitem__(k) %}
    {% endif %}
  {% endfor %}
  SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands VALUE="{
      commands|replace('\"','\\\"')}"

[gcode_macro pause_at_layer]
description: Convenience macro to schedule the current print to pause at the
  specified layer change. LAYER=next will cause the command to run at the next
  layer change. See PAUSE for additional arguments.
  Usage: PAUSE_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode:
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  " %} # End argument block for Mainsail
  {% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
  _CHECK_KINEMATIC_LIMITS{% for k in filtered_params%}{' ' ~k~ '=' ~ params[k]
   }{% endfor %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor
    %} COMMAND="PAUSE{% for k in filtered_params %}{
      ' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro speed_at_layer]
description: Convenience macro to schedule a feedrate adjustment at the
  specified layer change. LAYER=next will cause the command to run at the next
  layer change. (SPEED parameter behaves the same as the M220 S parameter.)
  Usage: SPEED_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } SPEED=<percentage>
gcode:
  {% set SPEED = params.SPEED|default(0)|int %}
  {% if SPEED < 1 or SPEED > 500 %}
    {action_raise_error("SPEED[%i] parameter between 1 and 500 is required."
                        % SPEED)}
  {% endif %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor %} COMMAND="M220 S{SPEED|int}"
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.SPEED|default(percentage)|int %}
  " %} # End argument block for Mainsail

[gcode_macro flow_at_layer]
description: Convenience macro to schedule a flow percentage adjustment at the
  specified layer change. LAYER=next will cause the command to run at the next
  layer change. (FLOW parameter behaves the same as the M221 S parameter.)
  Usage: FLOW_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } FLOW=<percentage>
gcode:
  {% set FLOW = params.FLOW|default(0)|int %}
  {% if FLOW < 1 or FLOW > 500 %}
    {action_raise_error("FLOW[%i] parameter between 1 and 500 is required."
                        % FLOW)}
  {% endif %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor %} COMMAND="M221 S{FLOW|int}"
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.FLOW|default(percentage)|int %}
  " %} # End argument block for Mainsail

[gcode_macro fan_at_layer]
description: Convenience macro to schedule a fan adjustment at the specified
  layer change. LAYER=next will cause the command to run at the next layer
  change. See SET_FAN_SCALING for additional arguments.
  Usage: FAN_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode:
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0)|int %}
  {% set dummy = params.MAXIMUM|default(0)|int %}
  {% set dummy = params.MINIMUM|default(255)|int %}
  {% set dummy = params.SPEED|default(current speed)|int %}
  " %} # End argument block for Mainsail
  {% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
  {% if filtered_params|length == 0 %}
    {action_raise_error("No fan parameters provided.")}
  {% endif %}
  _CHECK_FAN_PARAMS{% for k in filtered_params %}{' '~k~'='~params[k]
    }{% endfor %}
  GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor
    %} COMMAND="SET_FAN_SCALING{% for k in filtered_params %}{
      ' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro heater_at_layer]
description: Convenience macro to schedule a heater adjustment at the specified
  layer change. LAYER=next will cause the command to run at the next layer
  change. See SET_HEATER_SCALING for additional arguments.
  Usage: HEATER_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode:
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.LAYER|default(layer number)|float %}
  {% set dummy = params.HEIGHT|default(Z height)|int %}
  {% set dummy = params.HEATER|default(e.g. extruder) %}
  {% set dummy = params.SCALE|default(1.0)|float %}
  {% set dummy = params.BUMP|default(0.0)|float %}
  {% set dummy = params.MAXIMUM|default(max_temp)|float %}
  {% set dummy = params.MINIMUM|default(min_temp)|float %}
  {% set dummy = params.TARGET|default(current target)|float %}
  " %} # End argument block for Mainsail
  {% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
  _CHECK_HEATER_PARAMS{% for k in filtered_params%}{' ' ~ k ~ '=' ~ params[k]
    }{% endfor %}
  GCODE_AT_LAYER{% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
      ' ' ~ k ~ '=' ~ params[k] }{% endfor
    %} COMMAND="SET_HEATER_SCALING{% for k in filtered_params %}{
      ' ' ~ k ~ '=\\\"' ~ params[k]|replace('\\','\\\\')|replace('\'','\\\'')
                                   |replace('\"','\\\"') ~ '\\\"'
    }{% endfor %}"


    # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro park]
description: Park the toolhead
  Usage: PARK [P=<0|1|2>] [X=<pos>] [Y=<pos>] [Z=<pos>] [LAZY=<1|0>]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set LAZY = params.LAZY|default(1)|int %}
  {% if printer.toolhead.homed_axes != "xyz" %}
    {% if LAZY %}
      G28 O
    {% else %}
      {action_raise_error("Must home axes first.")}
    {% endif %}
  {% endif %}

  # Z position type from G27 (if below, absolute, relative)
  {% set P = (params.P|default(2))|int %} # Default to 2 because it's sanest.
  {% set X = params.X|default(km.park_x)|float %}
  {% set Y = params.Y|default(km.park_y)|float %}
  {% set Z = params.Z|default(km.park_z)|float %}

  _CHECK_KINEMATIC_LIMITS X="{X}" Y="{Y}" Z="{Z}"
  _PARK_INNER X="{X}" Y="{Y}" Z="{Z}" P="{P}" LAZY="{LAZY}"
  # Dummy argument block for Mainsail
  {% set dummy = None if True else "
  {% set dummy = params.P|default(mode=<0|1|2>)|int %}
  {% set dummy = params.X|default(X position)|int %}
  {% set dummy = params.Y|default(Y position)|int %}
  {% set dummy = params.Z|default(Z position)|int %}
  " %} # End argument block for Mainsail

[gcode_macro _park_inner]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set travel_speed_xy = km.travel_speed_xy %}
  {% set travel_speed_z = km.travel_speed_z %}

  {% set position = printer.gcode_move.gcode_position %}

  # Use the taller of the highest printed layer or the current Z height, which
  # should helps crashes e.g. when a sequential print in progress.
  {% set clearance_z = (printer["gcode_macro _km_layer_run"].clearance_z,
                        position.z) | max %}
  {% set P = params.P|int %}
  {% set X = params.X|float %}
  {% set Y = params.Y|float %}
  {% set Z = params.Z|float %}
  {% set LAZY = params.LAZY|int %}

  # Convert everything to absolute coordinates.
  # P == 1 is absolute, so needs no adjustment.
  {% if P == 0 %} # Move absolute to Z if below current Z
    {% if clearance_z > Z %}
      {% set Z = clearance_z %}
    {% endif %}
  {% elif P == 2 %} # Move Z relative
    {% set Z = Z + clearance_z %}
  {% elif P != 1 %}
    {action_raise_error("Invalid parameter P=%i. Value must be 0, 1, or 2." |
        format(P)) }
  {% endif %}

  # Clamp to the printer limits.
  {% set Z = ((Z, printer.toolhead.axis_maximum.z)|min,
              printer.toolhead.axis_minimum.z)|max %}

  # Don't move if it's a lazy park and we're already in position.
  {% if (not LAZY) or P != 2 or X != position.x or Y != position.y 
        or Z < clearance_z %}
    SAVE_GCODE_STATE NAME=PARK
    G90
    G0 Z{Z} F{travel_speed_z}
    G0 X{X} Y{Y} F{travel_speed_xy}
    RESTORE_GCODE_STATE NAME=PARK MOVE=0
  {% endif %}


[gcode_macro g27]
description: Parks the toolhead.
  Usage: G27 [P=<0|1|2>]
gcode:
  # Wraps any arguments for the PARK macro and defaults P=0 for Marlin compat.
  PARK P={params.P|default(0)} {% for k in params|reject("in", "GP") %}{
    ' '~k~'="'~params[k]~'"'
    }{% endfor %}



   # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

# Enables pause/resume functionality
[gcode_macro pause]
description: Pauses the current print.
  Usage: PAUSE [X=<pos>] [Y=<pos>] [Z=<pos>] [E=<retract_length>] [B=<beeps>]
rename_existing: _KM_PAUSE_BASE
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  # Retract length (negative)
  {% set E = (params.E|default(5))|float %}
  # Beeps
  {% set B = (params.B|default(10))|float %}

  {% if printer.virtual_sdcard.is_active %}
    {% set position = printer.gcode_move.gcode_position %}
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_x VALUE="{position.x}"
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_y VALUE="{position.y}"
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_z VALUE="{position.z}"
    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{E}"
    SAVE_GCODE_STATE NAME=PAUSE_override_state
    _KM_PAUSE_BASE
    M83
    G1 E{'%.4f' % -E} F{km.load_speed}
    PARK P=2{% for k in params|select("in", "XYZ") %}
      {' '~k~'="'~params[k]~'"'}
    {% endfor %}
    # Beep on pause if there's an M300 macro.
    {% if "output_pin beeper" in printer %}
      {% for i in range(B|int) %}
        M300 P100
        G4 P200
      {% endfor %}
    {% endif %}
  {% else %}
    { action_respond_info("Print from SD card is not in progress.") }
  {% endif %}

[gcode_macro m600]
description: Pauses the current print.
  Usage: M600 [B<beeps>] [E<pos>] [L<pos>] [R<temp>] [U<pos>] [X<pos>] [Y<pos>]
              [Z<pos>]
gcode:
  PAUSE P=2{% for k in params|select("in", "BEXYZ") %}{
      ' '~k~'="'~params[k]~'"'}{% endfor %}
  UNLOAD_FILAMENT{% if 'U' in params %} LENGTH={params.U}{% endif %}
  {% if 'R' in params %}M109 S{params.R}{% endif %}

[gcode_macro m601]
description: Pauses the current print.
  Usage: M601
gcode:
  PAUSE

[gcode_macro m602]
description: Resumes the currently paused print.
  Usage: M602
gcode:
  RESUME

[gcode_macro m24]
rename_existing: M24.6245197
gcode:
  {% if printer.pause_resume.is_paused %}
  RESUME
  {% else %}
  M24.6245197
  {% endif %}

[gcode_macro m25]
rename_existing: M25.6245197
gcode:
  PAUSE

[gcode_macro resume]
description: Resumes the currently paused print.
  Usage: RESUME [E<pos>]
rename_existing: _KM_RESUME_BASE
variable_saved_extruder_temp: 0
variable_saved_x: 0.0
variable_saved_y: 0.0
variable_saved_z: 0.0
variable_saved_e: 0.0
gcode:
  {% if printer.pause_resume.is_paused %}
    {% set km = printer["gcode_macro _km_globals"] %}
    # Warm the extruder back up if needed.
    {% set extruder = printer[printer.toolhead.extruder] %}
    {% if extruder.target <= printer.configfile.settings[
                               printer.toolhead.extruder].min_temp
                             | float + 0.5 %}
      M109 S{saved_extruder_temp}
    {% endif %}

    # If there's no saved_e assume we're completing a filament change and
    # retract enough to avoid drooling on the model.
    {% if 'E' not in params and not saved_e %}
      {% set saved_e = 5.0 %}
      G1 E{'%.4f' % -saved_e } F{km.load_speed}
    {% endif %}

    SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{0}"
    G90
    # Move back to last position before unretracting.
    G0 X{saved_x} Y{saved_y} F{km.travel_speed_xy}
    G0 Z{saved_z} F{km.travel_speed_z}
    G91
    # Unretract
    G1 E{'%.4f' % (params.E|default(saved_e))} F{km.load_speed}
    RESTORE_GCODE_STATE NAME=PAUSE_override_state MOVE=1
    _KM_RESUME_BASE
  {% else %}
    { action_respond_info("Printer is not paused.") }
  {% endif %}

[gcode_macro cancel_print]
description: Cancels the current print.
  Usage: CANCEL_PRINT
rename_existing: _KM_CANCEL_PRINT_BASE
gcode:
  {% set was_paused = printer.pause_resume.is_paused %}
  {% if was_paused or printer.idle_timeout.state|string == "Printing" %}
    PRINT_END
    SDCARD_RESET_FILE
  {% else %}
    { action_respond_info("No print from SD card in progress.") }
  {% endif %}
  _KM_CANCEL_PRINT_BASE
  {% if was_paused %}
    RESTORE_GCODE_STATE NAME=PAUSE_override_state MOVE=0
  {% endif %}
  CLEAR_PAUSE

[gcode_macro clear_pause]
description: Clears the current pause state.
  Usage: CLEAR_PAUSE
rename_existing: _KM_CLEAR_PAUSE
gcode:
  SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{0.0}"
  SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{0}"
  _KM_CLEAR_PAUSE


  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro print_start]
description: Inserted by slicer at start of print.
  Usage: PRINT_START BED=<temp> EXTRUDER=<temp> [CHAMBER=<temp>]
                     [MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [LAYERS=<num>]
gcode:
  CLEAR_PAUSE
  {% set BED = params.BED|default(params.BED_TEMP)|float %}
  {% set EXTRUDER = params.EXTRUDER|default(params.EXTRUDER_TEMP)|float %}
  {% set CHAMBER = params.CHAMBER|default(0)|float
                   if "chamber" in printer.heaters.available_heaters else 0.0 %}
  {% set settings = printer["gcode_macro print_start_set"].settings %}
  {% set MESH_MIN = params.MESH_MIN|default(settings.MESH_MIN)|default(None) %}
  {% set MESH_MAX = params.MESH_MAX|default(settings.MESH_MAX)|default(None) %}
  {% set LAYERS = params.LAYERS|default(settings.LAYERS)|default(-1)|int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set bed_overshoot = (BED + (km.start_bed_heat_overshoot if BED else 0.0),
           printer.configfile.settings.heater_bed.max_temp ) | min %}

  INIT_LAYER_GCODE LAYERS="{LAYERS}"
  {% if CHAMBER > 0.0 %}
    M141 S{CHAMBER}
  {% endif %}
  # Start bed heating
  M140 S{bed_overshoot}
  {% if km.start_level_bed_at_temp %}
    # If we're going to run a bed level we heat the extruder only part way to
    # avoid oozing all over the bed while probing.
    M104 S{(km.start_extruder_preheat_scale * EXTRUDER)|round(0,'ceil')|int}
  {% else %}
    M104 S{EXTRUDER}
  {% endif %}
  # home all axes
  G28
  G90
  PARK
  {% if BED > 0.0 %}
    # Overshoot the target a bit.
    M190 S{bed_overshoot}
    G4 P{km.start_bed_heat_delay / 2}
    M190 R{BED} # Settle down after the overshoot.
    G4 P{km.start_bed_heat_delay / 2}
  {% endif %}
  {% if CHAMBER > 0.0 %}
    M191 S{CHAMBER}
  {% endif %}
  {% if km.start_level_bed_at_temp %}
    M104 S{EXTRUDER} # set the final extruder target temperature
    G28 Z # Re-home only the Z axis now that the bed has stabilized.
    BED_MESH_CALIBRATE_FAST{% if MESH_MIN %} MESH_MIN={MESH_MIN}{% endif
                         %}{% if MESH_MAX %} MESH_MAX={MESH_MAX}{% endif %}
    PARK
  {% endif %}
  # Wait for extruder to reach temperature
  M109 S{EXTRUDER}
  # apply Z offset for bed surface (just in case it was reset).
  _APPLY_BED_SURFACE_OFFSET

[gcode_macro print_start_set]
description: Inserted by slicer to set values used by PRINT_START.
  Usage: PRINT_START_SET <VARIABLE>=<value>
variable_settings: {}
gcode:
  {%for k in params %}
    {% set dummy = settings.__setitem__(k|upper, params[k]) %}
  {% endfor %}

[gcode_macro print_end]
description: Inserted by slicer at end of print.
  Usage: PRINT_END
gcode:
  M400
  G92 E0
  G1 E-5.0 F3600

  {% set km = printer["gcode_macro _km_globals"] %}
  {% set toolhead = printer.toolhead %}
  {% set max_x = toolhead.axis_maximum.x %}
  {% set max_y = toolhead.axis_maximum.y %}
  {% set max_z = toolhead.axis_maximum.z %}
  {% set x_safe = (max_x - toolhead.position.x, 5.0)|min %}
  {% set y_safe = (max_y - toolhead.position.y, 5.0)|min %}
  {% set z_safe = (max_z - toolhead.position.z, 2.0)|min %}

  # Wipe if we're not cancelling a paused print.
  {% if not printer.pause_resume.is_paused %}
    G91
    G0 Z{z_safe} F{km.travel_speed_z * 2} ; move nozzle up
    G0 X{x_safe} Y{y_safe} F{km.travel_speed_xy} ; remove stringing
  {% endif %}
  {% if km.start_clear_adjustments_at_end != 0 %}
    RESET_HEATER_SCALING
    RESET_FAN_SCALING
    M220 S100
    M221 S100
  {% endif %}
  _RESET_LAYER_GCODE
  _RESET_VELOCITY_LIMITS
  TURN_OFF_HEATERS
  M107; turn off fan
  PARK Y={max_y}
  M84 ; disable steppers
  CLEAR_PAUSE

  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro _km_save_state]
description: Tracks gcode state.
variable_state_set: {}
variable_is_ephemeral: 0
gcode:
  {% if params.SAVE|int %}
    {% set dummy = state_set.__setitem__(params.NAME, None) %}
  {% else %}
    {% set dummy = state_set.__delitem__(params.NAME) %}
  {% endif %}
  SET_GCODE_VARIABLE MACRO=_km_save_state VARIABLE=is_ephemeral VALUE="{
    1 if state_set|length > 0 else 0 }"

[gcode_macro save_gcode_state]
description: Wraps SAVE_GCODE_STATE to track persistence state.
  Usage: See Klipper documentation
rename_existing: _KM_SAVE_GCODE_STATE
gcode:
  _KM_SAVE_GCODE_STATE {rawparams}
  {% set NAME = params.NAME|default("default") %}
  _km_save_state NAME={NAME} SAVE=1

[gcode_macro restore_gcode_state]
description: Wraps RESTORE_GCODE_STATE to track persistence state.
  Usage: See Klipper documentation
rename_existing: _KM_RESTORE_GCODE_STATE
gcode:
  _KM_RESTORE_GCODE_STATE {rawparams}
  {% set NAME = params.NAME|default("default") %}
  _km_save_state NAME={NAME} SAVE=0


  # Copyright (C) 2022 Justin Schuh <code@justinschuh.com>
#
# This file may be distributed under the terms of the GNU GPLv3 license.

[gcode_macro m201]
description: Sets maximum accelleration.
  Usage: M201 [X<accel>] [Y<accel>]
variable_max_accel: 1.7976931348623157e+308
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if 'X' in params or 'Y' in params %}
    {% set accel = (params.X|default(params.Y)|float,
                    params.Y|default(params.X)|float)|min %}
    SET_GCODE_VARIABLE MACRO=m201 VARIABLE=max_accel VALUE="{accel}"
    {% if accel < printer.toolhead.max_accel %}
      SET_VELOCITY_LIMIT ACCEL="{accel
                      }" ACCEL_TO_DECEL="{accel * km.velocity_decel_scale}"
    {% endif %}
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m203]
description: Sets maximum velocity.
  Usage: M203 [X<velocity>] [Y<velocity>]
gcode:
  {% if 'X' in params or 'Y' in params %}
    {% set velocity = (params.X|default(params.Y)|float,
                       params.Y|default(params.X)|float)|min %}
    SET_VELOCITY_LIMIT VELOCITY="{velocity}"
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m204]
description: Sets maximum accelleration.
  Usage: M204 [S<accel>] [P<accel> T<accel>]
rename_existing: M204.6245197
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set max_accel = printer["gcode_macro m201"].max_accel %}
  {% set accel = 0.0 %}
  {% if 'S' in params %}
    {% set accel = (params.S|float, max_accel)|min %}
  {% elif 'P' in params %}
    {% set accel = (params.P|float, params.T|default(params.P)|float,
                    max_accel)|min %}
  {% endif %}
  {% if accel %}
    SET_VELOCITY_LIMIT ACCEL="{accel
                     }" ACCEL_TO_DECEL="{accel * km.velocity_decel_scale}"
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m205]
description: Sets square corner velocity.
  Usage: M203 [X<velocity>] [Y<velocity>]
gcode:
  {% if 'X' in params or 'Y' in params %}
    SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY="{
      (params.X|default(0)|float, params.Y|default(0)|float)|min}"
  {% else %}
    SET_VELOCITY_LIMIT
  {% endif %}

[gcode_macro m900]
description: Sets pressure advance.
  Usage: M900 [K<advance>] [T<extruder_index>]
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if km.pressure_advance_scale > 0.0 %}
    {% set extruder = printer["extruder" ~ params.T]
      if params.T|default(0)|int != 0 else printer.toolhead.extruder %}
    {% if 'K' in params %}
      SET_PRESSURE_ADVANCE EXTRUDER="{extruder}" ADVANCE="{
        params.K|float * km.pressure_advance_scale}"
    {% endif %}
  {% endif %}


[gcode_macro _reset_velocity_limits]
description: Sets maximum accelleration.
  Usage: M204 [S<accel>] [P<accel> T<accel>]
gcode:
  SET_GCODE_VARIABLE MACRO=m201 VARIABLE=max_accel VALUE="{1.7976931348623157e+308}" 